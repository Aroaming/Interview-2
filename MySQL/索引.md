# Mysql面试问题----索引

#### 索引的好坏直接影响数据库的性能，所以索引的面试题也是面试中必问的问题

1. # 为什么要使用索引

   ## 要点：建立索引的主要原因
   ## 详解：通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   ## 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
   ## 帮助服务器避免排序和临时表。
   ## 将随机IO变为顺序IO
   ## 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义

2. # 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？

   ## 要点：索引的优缺点

   ## 详解：创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。占用物理存储空间 ：索引需要使用物理文件存储，也会耗费一定空间。

3. # 使用索引的注意事项？

   ## 要点：索引经常遇到的问题，如何更好的建立索引

   ## 详解：在经常需要搜索的列上，可以加快搜索的速度；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引；在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；避免 where 子句中对字段施加函数，这会造成无法命中索引；在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键

4. # B树和B+树区别

   ## 要点：节点存放的数据

   ## 详解：B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。
   B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。

5. # 聚集索引与非聚集索引

   ## 要点：索引结构与数据是否存放在一起

   ## 详情：聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引，在 Mysql 中，InnoDB引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据
   非聚集索引即索引结构和数据分开存放的索引。MYISAM引擎的表的.MYI文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据

6. # 非聚集索引一定回表查询吗(覆盖索引)?

   ## 要点：覆盖索引定义：如果一个索引包含（或者说覆盖）所有需要查询的字段的值

   ## 详情：覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询

   

7. # Mysql四种索引类型

   ## 要点：主键索引/二级索引(辅助索引)/聚集索引与非聚集索引/覆盖索引

   ## 详解：

8. # Mysql索引主要使用的两种数据结构

   ## 要点：哈希索引和BTREE索引

   ## 详解：哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引

   

9. # MyISAM和InnoDB实现BTree索引方式的区别

   ## 要点：聚集索引和非聚集索引

   ## 详解：同上第五道题

10. # 为什么索引能提高查询速度

    ## 要点：就是将无序的数据变成有序(相对)

11. # 最左前缀原则

    ## 如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到

12. # Mysql如何为表字段添加索引

    ## 要点：添加各种索引的写法

    ## 详解：--PRIMARY KEY      --UNIQUE	  --INDEX 		--FULLTEXT  

13. # 不使用索引的原因列举

    ## 要点：索引失效的原因

    ## 详解：

    ### 1) 没有查询条件，或者查询条件没有建立索引; 

    ### 2) 在查询条件上没有使用引导列

    ### 3) 查询的数量是大表的大部分，应该是30％以上。

    ### 4) 索引本身失效 

    ### 5) 查询条件使用函数在索引列上（见12） 

    ### 6) 对小表查询 

    ### 7) 提示不使用索引

    ### 8) 统计数据不真实

    ### 9) CBO计算走索引花费过大的情况。其实也包含了上面的情况，这里指的是表占有的block要比索引小。

    ### 10)隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20)

    ### 11)对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，\*，/，! 等)

    ### 12)使用mysql内部函数导致索引失效.对于这样情况应当创建基于函数的索引. 

14. # 索引创建原则

    ## 要点：最左，单列，联合

    ## 详解：单列索引即由一列属性组成的索引。联合索引即由多列属性组成索引。创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件

15. # 索引创建注意点

    ## 要点：合适的字段/最左

    ## 详解：什么适合建立索引，什么不适合

    ### 1.不为NULL的字段:  索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。
    ### 2.被频繁查询的字段:  我们创建索引的字段应该是查询操作非常频繁的字段。

    ### 3.被作为条件查询的字段:被作为WHERE条件查询的字段，应该被考虑建立索引。

    ### 4.被经常频繁用于连接的字段:  经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

    ### 5.被频繁更新的字段应该慎重建立索引:  虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

    ### 6.不被经常查询的字段没有必要建立索引
    ### 7.尽可能的考虑建立联合索引而不是单列索引:  因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

    ### 8.注意避免冗余索引:  冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

    ### 9.考虑在字符串类型的字段上使用前缀索引代替普通索引:前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

16. # 使用索引一定能提高查询性能吗?

    ## 要点：什么时候建了索引反而会比没有索引慢

    ## 详解：索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升

答案见下:

[https://blog.csdn.net/GFDGFHSDS/article/details/105379052]

[https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.md ]

[https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL%20Index.md]

